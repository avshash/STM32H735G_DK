#include "common.h"
#include "String.h"

char String::m_null_string[1] = {0};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String::String ()
: m_string_len (0),
  m_string (m_null_string)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String::String (const char * string)
: m_string_len (0),
  m_string (m_null_string)
{
  if (string != NULL)
  {
    append (string, strlen (string));
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String::String (const char * string, uint32_t string_len)
: m_string_len (0),
  m_string (m_null_string)
{
  append (string, string_len);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String::String (const String & source)
: m_string_len (0),
  m_string (NULL)
{
  append (source.m_string, source.m_string_len);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   destructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String::~String ()
{
  if ((m_string != NULL) && (m_string != m_null_string))
  {
    free (m_string);
    m_string = NULL;
    m_string_len = 0;
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   release
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char *
String::release ()
{
  if (m_string == m_null_string)
  {
    return NULL;
  }

  char * ret_val = m_string;
  m_string = m_null_string;
  m_string_len = 0;

  return ret_val;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   stringLen
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t
String::stringLen () const
{
  return m_string_len;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   cStr
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const char *
String::cStr () const
{
  if (m_string == NULL)
  {
    return "";
  }

  return m_string;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   append
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String &
String::append (const char * postfix, uint32_t postfix_len)
{
  if ((0 < postfix_len) || (m_string == m_null_string))
  {
    uint32_t new_len = postfix_len + m_string_len;
    char * new_string = (char *) malloc  (new_len + 1);
    TEST_MALLOC_OUT_OF_MEMORY (new_string);

    memcpy (new_string, m_string, m_string_len);
    memcpy (new_string + m_string_len, postfix, postfix_len);
    new_string[new_len] = 0;

    if (m_string != m_null_string)
    {
      free (m_string);
    }

    m_string = new_string;
    m_string_len = new_len;
  }

  return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   moveString
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
String::moveString (String & source)
{
  INTERNAL_ASSERT (m_string == m_null_string);

  m_string = source.m_string;
  m_string_len = source.m_string_len;

  source.m_string = m_null_string;
  source.m_string_len = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator<<
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String &
String::operator<< (const char * postfix)
{
  if (postfix == NULL)
  {
    return *this;
  }

  return append (postfix, strlen (postfix));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator<<
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
String &
String::operator<< (const String & postfix)
{
  if (postfix.m_string == m_null_string)
  {
    return *this;
  }

  return append (postfix.m_string, postfix.m_string_len);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator==
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool
String::operator== (const String & other) const
{
  if (other.m_string_len != m_string_len)
  {
    return false;
  }

  if (m_string_len == 0)
  {
    return true;
  }

  return (memcmp (other.m_string, m_string, m_string_len) == 0);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator==
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool
String::operator== (const char * other) const
{
  if (other == NULL)
  {
    return (m_string == m_null_string);
  }

  if (strlen (other) != m_string_len)
  {
    return false;
  }

  if (m_string_len == 0)
  {
    return true;
  }

  return (memcmp (other, m_string, m_string_len) == 0);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator!=
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool
String::operator!= (const char * other) const
{
  return !(*this == other);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator!=
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool
String::operator!= (const String & other) const
{
  return !(*this == other);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   operator[]
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char
String::operator[] (int index) const
{
  INTERNAL_ASSERT (((uint32_t) index) <= m_string_len);

  if (((uint32_t) index) == m_string_len)
  {
    return 0;
  }

  return m_string[index];
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    String
// @method:   hash
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t
String::hash (uint32_t mod) const
{
  uint32_t result = 0;
  uint8_t const * base = (const uint8_t *) m_string;
  const uint8_t * limit = (const uint8_t *) (base + m_string_len);
  while (base < limit)
  {
    uint32_t new_val = *base;
    result = new_val + (result << 6) + (result << 16) - result;
    base++;
  }

  return (result % mod);
}

