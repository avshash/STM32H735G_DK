#include "common.h"
#include "Module.h"

#include "SinglePathData.h"
#include "ActiveObject.h"
#include "Configuration.h"
#include "FileWriter.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Module::Module () :
  m_active (false),
  m_paths_data (),
  m_module_params ()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Module::~Module ()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   addSinglePathData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
Module::addSinglePathData (const Library & library, const String & path)
{
  SinglePathData * single_ptr = new SinglePathData (library, path);
  m_paths_data.enqueue (single_ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   setModuleActive
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
Module::setModuleActive (Configuration & configuration, const String & module_name)
{
  if (isActive ())
  {
    return;
  }

  m_active = true;
  appendModuleParam ("MODULE_ACTIVE", module_name);

  INTERNAL_ASSERT (this == &(static_cast <Module &> (configuration.getObject (module_name))));

  fprintf (stdout, "Activate module '%s'.\n", module_name.cStr ());

  activateModule (configuration);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   activateModule
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
Module::activateModule (Configuration & configuration)
{
  uint32_t singles_count = m_paths_data.queueSize ();
  for (uint32_t single_index = 0; single_index < singles_count; single_index++)
  {
    Object & module_single_object = m_paths_data.getMember (single_index);
    SinglePathData & module_single = static_cast <SinglePathData &> (module_single_object);

    module_single.activateSingle (configuration, *this);
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   writeModuleRule
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
Module::writeModuleRule (FileWriter & makefile) const
{
  if (!isActive ())
  {
    return;
  }

  uint32_t params_count = m_module_params.queueSize ();
  for (uint32_t path_index = 0; path_index < params_count; path_index = path_index + 2)
  {
    if (m_module_params.getMember (path_index) == "MODULE_ACTIVE")
    {
      makefile << m_module_params.getMember (path_index + 1) << ": \\\n";
      break;
    }
  }

  for (uint32_t path_index = 0; path_index < params_count; path_index = path_index + 2)
  {
    if (m_module_params.getMember (path_index) == "TARGET_RULE")
    {
      makefile << "\t" << m_module_params.getMember (path_index + 1) << " \\\n";
    }
  }

  makefile << "\n\n";
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   writeCompilationRules
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
Module::writeCompilationRules (FileWriter & makefile) const
{
  if (!isActive ())
  {
    return;
  }

  uint32_t paths_count = m_paths_data.queueSize ();
  for (uint32_t path_index = 0; path_index < paths_count; path_index++)
  {
    const Object & single_path_object = m_paths_data.getMember (path_index);
    const SinglePathData & single_path = static_cast <const SinglePathData &> (single_path_object);

    single_path.writeCompilationRules (makefile);
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   appendModuleParam
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
Module::appendModuleParam (const char * param_name, const String & param_value)
{
  m_module_params.enqueue (param_name);
  m_module_params.enqueue (param_value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   getModuleParams
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const QueueString &
Module::getModuleParams () const
{
  return m_module_params;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   isActive
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool
Module::isActive () const
{
  return m_active;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    Module
// @method:   objectType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TypeObject
Module::objectType () const
{
  return OBJECT_MODULE;
}


