#include "common.h"
#include "FileBuffer.h"

#include "FileReader.h"
#include "Central.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FileBuffer::FileBuffer (const char * file_name_postfix, const String & file_name_prefix)
: m_file_path (),
  m_file_name (),
  m_offset (0),
  m_buffer_size (0),
  m_buffer (NULL)
{
  String complete_file_name;
  complete_file_name << file_name_prefix << file_name_postfix;
  parseFileName (complete_file_name);

  loadFile ();
  parseBuffer ();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   destructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FileBuffer::~FileBuffer ()
{
  if (m_buffer != NULL)
  {
    free (m_buffer);
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   loadFile
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
FileBuffer::loadFile ()
{
  String complete_file_name;
  complete_file_name << Central::path (PATH_BIN_2_SOURCE) << m_file_path << m_file_name;

  FileReader fr (complete_file_name);

  uint32_t file_size = fr.fileSize ();
  m_buffer = (char *) malloc (file_size + 2);
  TEST_MALLOC_OUT_OF_MEMORY (m_buffer);
  
  try
  {
    fr.readFile (m_buffer);
  }
  catch (...)
  {
    free (m_buffer);
    m_buffer = NULL;
    throw;
  }

  m_buffer_size = file_size;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   parseBuffer
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
FileBuffer::parseBuffer ()
{
  uint32_t offset_target = 0;
  for (uint32_t offset_source = 0; offset_source < m_buffer_size; offset_source++)
  {
    char next_val = m_buffer[offset_source];
    switch (next_val)
    {
      case '\n':
        next_val = 0;
        break;

      case '\\':
        offset_source++;
        VERIFY_INPUT_VALID (offset_source < m_buffer_size, "Input file should not terminate with '\\'.");
        next_val = getSpecialCharacter (m_buffer[offset_source]);
        break;

      default:
        break;
    }

    m_buffer[offset_target] = next_val;
    offset_target++;
  }

  m_buffer[offset_target] = 0;
  m_buffer[offset_target + 1] = 0;
  m_buffer_size = offset_target;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   getSpecialCharacter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char
FileBuffer::getSpecialCharacter (char type_char)
{
  switch (type_char)
  {
    case 'n':
      return '\n';

    case 't':
      return '\t';

    default:
      break;
  }

  return type_char;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   readLine
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const char *
FileBuffer::readLine ()
{
  if (m_buffer_size <= m_offset)
  {
    return NULL;
  }

  const char * ret_val = m_buffer + m_offset;

  while (m_buffer[m_offset] != 0)
  {
    m_offset++;
  }
  m_offset++;

  return ret_val;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   resetRead
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
FileBuffer::resetRead ()
{
  m_offset = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   parseFileName
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void
FileBuffer::parseFileName (const String & file_name)
{
  uint32_t seperator_offset = 0;
  uint32_t file_name_length = file_name.stringLen ();
  const char * c_file_name = file_name.cStr ();
  for (uint32_t offset = 0; offset < file_name_length; offset++)
  {
    if (c_file_name[offset] == '/')
    {
      seperator_offset = offset + 1;
    }
  }

  m_file_path.append (c_file_name, seperator_offset);
  m_file_name.append (c_file_name + seperator_offset, file_name_length - seperator_offset);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   filePath
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const String &
FileBuffer::filePath () const
{
  return m_file_path;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// @class:    FileBuffer
// @method:   fileName
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const String &
FileBuffer::fileName () const
{
  return m_file_name;
}


